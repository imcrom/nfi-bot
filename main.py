import logging
import requests
import aiohttp
import aiofiles
import asyncio
import math
import os
import io
from aiogram import Bot, Dispatcher, executor, types
from aiogram.contrib.middlewares.logging import LoggingMiddleware
from aiogram.types import Message
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from PIL import ImageDraw, ImageFont, Image

API_TOKEN = '6011101790:AAG5AP5gZYEH_p4ppe7g9ex75NhppFvrQF0'
# Configure logging
logging.basicConfig(level=logging.INFO)
# Initialize bot and dispatcher
bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

@dp.message_handler(commands='start')
async def gen(message: Message):
    await bot.send_photo(
            chat_id=message.chat.id,
            caption=f'Hello {message.from_user.first_name}, My name is Non-Fungible Intelligence Bot, I can generate images from what you send to me.\n\nYou can use the /nfi command followed by what you want me to generate\n\neg.\n/nfi Unicorn, rainbow, flying, mountain.',
            photo='https://i.ibb.co/6vDkRKH/desc.png',
    )

@dp.message_handler(commands='nfi')
async def gen(message: Message):
    inputs = message.text.split()[1:]  # Split the message and get all inputs after the /gen command
    if not inputs:
        await bot.send_message(
            chat_id=message.chat.id,
            text=f'Hello {message.from_user.first_name}, Please give me something to generate after the /nfi command',
        )
        return
    
    await bot.send_message(
        chat_id=message.chat.id,
        text=f'Greetings {message.from_user.first_name}!\n\nThis is what I will be creating\n\n({" ".join(inputs)})\n\n\n',
    )
    await requestApi(message, " ".join(inputs), 1)
   
   
   
async def send_image(message: Message, file_name: str, prompt: str, model: str):
    with open(f'{file_name}_watermarked.png', 'rb') as file:
        await bot.send_photo(
            chat_id=message.chat.id,
            caption=f'Amazing work by {message.from_user.first_name}!\nWow here are the details.\n\nPROMPT:\n({prompt})\n\nModel: {model}\n\nGenerated by: {message.from_user.first_name}\n\nNon-Fungible Intelligence Bot\n\n\n',
            photo=types.InputFile(file),
        )
   
    
async def processing_update(message: Message, eta: int):
	await bot.send_message(
		chat_id=message.chat.id,
		text=f'Hi {message.from_user.first_name}!\n\nYour image is still undergoing proccessing.\n\nETA: {math.ceil(eta)} seconds.\n',
	)

async def error_update(message: Message):
	await bot.send_message(
		chat_id=message.chat.id,
		text=f'Hi {message.from_user.first_name}!\n\nSorry about that! but there has been an error generating your image\n\nThe good thing is you can try again!\n',
	)



async def requestApi(message, prompt, model):
    if model == 1:
        model = 'realistic-vision-v13'
    if model == 2:
        model = 'hassanblend-1512'
    if model == 3:
        model = 'protogen-3.4'
    url = 'https://stablediffusionapi.com/api/v3/dreambooth'
    headers = {
        'Content-Type': 'application/json'
    }
    payload = {
        'key': 'YimEHAg0HxDBkYtZp7X8ZEv7u84XWtt66TgVA78BnGWQlLHe6cdoDQREjpV5',
        'model_id': model,
        'prompt': prompt,
        'negative_prompt': 'painting, extra fingers, mutated hands, poorly drawn hands, poorly drawn face, deformed, ugly, blurry, bad anatomy, bad proportions, extra limbs, cloned face, skinny, glitchy, double torso, extra arms, extra hands, mangled fingers, missing lips, ugly face, distorted face, extra legs, anime',
        'width': '512',
        'height': '512',
        'samples': '1',
        'num_inference_steps': '30',
        'seed': None,
        'guidance_scale': 7.5,
        'webhook': None,
        'track_id': None,
        'safety_checker': 'yes'
    }
    
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, json=payload) as resp:
                print('sent request')
                data = await resp.json()
                print(data)
                if resp.status == 200:
                    if data['status'] == 'success':
                        await downloadImage(data['id'], data['output'][0], message, prompt, model)
                        break
                    if data['status'] == 'processing' and data['messege'] == 'Request processing':
                        print('Requesting again')
                        await requestApi(message, prompt, model)
                    if data['status'] == 'processing':
                        if 'fetch_result' in data:
                            url = data['fetch_result']
                        await processing_update(message, data['eta'])
                        await asyncio.sleep(math.ceil(data['eta']))
                        continue
                    if data['status'] == 'error':
                        await error_update(message)
                        break
                    if data['status'] == 'failed':
                        continue
                    else:
                        raise Exception(f'Request failed with status code {resp.status}')
                    
# Start of watermark implementation
async def downloadImage(id: int, downloadUrl: str, message: Message, prompt: str, model: str):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(downloadUrl) as resp:
                if resp.status == 200:
                    f = await aiofiles.open(f'{id}.png', mode='wb')
                    await f.write(await resp.read())
                    # call watermark function
                    await add_watermark(f'{id}.png', '')
                    await send_image(message, id, prompt, model)
                    os.remove(f'{id}.png')
                    os.remove(f'{id}_watermarked.png')
                    await f.close()
    except Exception as e:
        print(f'An error occurred: {e}')

async def add_watermark(file_path: str, watermark_text: str) -> None:
    async with aiofiles.open(file_path, "rb") as file:
        img_data = await file.read()
        with io.BytesIO(img_data) as img_stream:
            img = Image.open(img_stream)
            draw = ImageDraw.Draw(img)
            font = ImageFont.truetype('FeatureMono-Bold.ttf', 24)
            
            textwidth, textheight = draw.textsize(watermark_text, font)
            width, height = img.size
            x = width / 2 - textwidth / 2
            y = height - textheight - 300

            draw.text((x, y), watermark_text, font=font)
            new_file_path = file_path.split('.')[0] + '_watermarked.png'
            img.save(new_file_path)


dp.middleware.setup(LoggingMiddleware())
if __name__ == '__main__':
	executor.start_polling(dp, skip_updates=True )